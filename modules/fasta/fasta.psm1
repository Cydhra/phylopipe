<#
 .SYNOPSIS
 Imports a Multi-FASTA file into a hashtable mapping the identifiers to sequences.

 .DESCRIPTION
 Imports one or multiple sequences from a FASTA file into a map, where the keys are the sequence identifiers,
 and the values are the state sequences with whitespace removed. The identifiers contain the
 '>' characters used by FASTA.

 .PARAMETER Path
 Path to a fasta file containing the sequences.

 .OUTPUTS [System.Collections.Hashtable]
 Returns a map of all sequences in the FASTA file.
#>
function Import-MultiFasta {
    param(
        [Parameter(Mandatory = $true)]
        [string] $Path
    )

    $FileContent = Get-Content -Path $Path -Raw
    Return ConvertFrom-MultiFasta -Fasta $FileContent
}

<#
 .SYNOPSIS
 Converts a Multi-FASTA string into a hashtable mapping the identifiers to sequences.

 .DESCRIPTION
 Imports one or multiple sequences from a FASTA string into a map, where the keys are the sequence identifiers,
 and the values are the state sequences with whitespace removed. The identifiers contain the
 '>' characters used by FASTA.

 .PARAMETER Fasta
 Fasta data containing the sequences.

 .OUTPUTS [System.Collections.Hashtable]
 Returns a map of all sequences in the FASTA file.
#>
function ConvertFrom-MultiFasta {
    param(
        [Parameter(Mandatory = $true)]
        [string] $Fasta
    )

    $SequenceMap = @{}
    $Entries = $FileContent -split '(?=\n>[^>]+)'

    $Entries | ForEach-Object {
        $Data = ($_ -split '\r?\n') | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' }
        $Descriptor = $Data[0]
        $StateSequence = $Data[1..($Data.Length - 1)] -join ""
        $SequenceMap[$Descriptor] = $StateSequence
    }

    return $SequenceMap
}

<#
 .SYNOPSIS
 Exports a hashtable containing FASTA names and sequences into a Multi-FASTA file.

 .DESCRIPTION
 Exports one or multiple sequences from a map, where the keys are the sequence identifiers,
 and the values are the state sequences into a Multi-FASTA file.

 .PARAMETER Sequences
 Hashtable containing the mapping of sequence identifiers to sequences.

 .PARAMETER Path
 Path to the output file.
#>
function Export-MultiFasta {
    param(
        [Parameter(Mandatory = $true)]
        [System.Collections.Hashtable] $Sequences,

        [Parameter(Mandatory = $true)]
        [string] $Path
    )

    ConvertTo-MultiFasta -Sequences $Sequences | Set-Content -Path $Path -NoNewline
}

<#
 .SYNOPSIS
 Converts a hashtable containing FASTA names and sequences into a FASTA string.

 .DESCRIPTION
 Serializes one or multiple sequences from a map, where the keys are the sequence identifiers,
 and the values are the state sequences into a Multi-FASTA string.

 .PARAMETER Sequences
 Hashtable containing the mapping of sequence identifiers to sequences.

 .OUTPUTS [String]
 Returns a the sequences serialized as FASTA data.
#>
function ConvertTo-MultiFasta {
    param(
        [Parameter(Mandatory = $true)]
        [System.Collections.Hashtable] $Sequences
    )

    Return ($Sequences.getEnumerator() | ForEach-Object {
        $_.Key
        $_.Value
    }) -join "`n"
}

<#
 .SYNOPSIS
 Imports an Ensemble-FASTA file (.efa) into a hashtable mapping the ensemble identifiers to MSA hashtables.

 .DESCRIPTION
 Imports one or multiple MSAs from an Ensemble-FASTA file into a map, where the keys are the ensemble identifiers,
 and the values are MSA hashtables, as they would be generated by Import-MultiFasta. The identifiers contain the
 '>' and '<' characters used by FASTA.

 .PARAMETER Path
 Path to a fasta file containing the sequences.

 .OUTPUTS [System.Collections.Hashtable]
 Returns a map of all MSAs in the Ensemble-FASTA file.
#>
function Import-EnsembleFasta {
    param (
        [Parameter(Mandatory = $true)]
        [string] $Path
    )

    $FileContent = Get-Content -Path $Path -Raw
    Return ConvertFrom-EnsembleFasta -Fasta $FileContent
}

<#
 .SYNOPSIS
 Imports an Ensemble-FASTA string into a hashtable mapping the ensemble identifiers to MSA hashtables.

 .DESCRIPTION
 Imports one or multiple MSAs from an Ensemble-FASTA string into a map, where the keys are the ensemble identifiers,
 and the values are MSA hashtables, as they would be generated by ConvertFrom-MultiFasta. The identifiers contain the
 '>' and '<' characters used by FASTA.

 .PARAMETER Fasta
 Fasta string containing the MSAs.

 .OUTPUTS [System.Collections.Hashtable]
 Returns a map of all MSAs in the Ensemble-FASTA file.
#>
function ConvertFrom-EnsembleFasta {
    param (
        [Parameter(Mandatory = $true)]
        [string] $Fasta
    )

    $EnsembleMap = @{}
    $EnsembleEntries = $FileContent -split '(?=\n<[^<]+)'

    $EnsembleEntries | ForEach-Object {
        $EnsembleData = ($_ -split '\r?\n') | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' }
        $EnsembleDescriptor = $EnsembleData[0]
        $EnsembleData = $EnsembleData[1..($EnsembleData.Length - 1)] -join ""

        $SequenceMap = ConvertFrom-MultiFasta -Fasta $EnsembleData
        $EnsembleMap[$EnsembleDescriptor] = $SequenceMap
    }

    Return $EnsembleMap
}

<#
 .SYNOPSIS
 Exports a hashtable containing FASTA ensembles into an Ensemble-FASTA file.

 .DESCRIPTION
 Exports one or multiple MSAs from a map, where the keys are the ensemble identifiers,
 and the values are the MSA hashtables into a Ensemble-FASTA file.

 .PARAMETER Sequences
 Hashtable containing the mapping of ensemble identifiers to MSAs.

 .PARAMETER Path
 Path to the output file.
#>
function Export-EnsembleFasta {
    param(
        [Parameter(Mandatory = $true)]
        [System.Collections.Hashtable] $Sequences,

        [Parameter(Mandatory = $true)]
        [string] $Path
    )

    ConvertTo-EnsembleFasta -Sequences $Sequences | Set-Content -Path $Path -NoNewline
}

<#
 .SYNOPSIS
 Converts a hashtable containing FASTA ensembles into an Ensemble-FASTA string.

 .DESCRIPTION
 Converts one or multiple MSAs from a map, where the keys are the ensemble identifiers,
 and the values are the MSA hashtables into a Ensemble-FASTA string.

 .PARAMETER Sequences
 Hashtable containing the mapping of ensemble identifiers to MSAs.

 .OUTPUTS [String]
 Returns a the MSAs serialized as FASTA data.
#>
function ConvertTo-EnsembleFasta {
    param(
        [Parameter(Mandatory = $true)]
        [System.Collections.Hashtable] $Sequences
    )

    Return ($Sequences.getEnumerator() | ForEach-Object {
        $_.Key
        ConvertTo-MultiFasta -Sequences $_.Value
    }) -join "`n"
}

<#
 .SYNOPSIS
 Generates a copy of a given MSA and removes all singleton sites from it.

 .PARAMETER KeepMonomorphic
 If true, does not remove monomorphic sites (i.e. sites which have no mutation at all)
#>
function Remove-SingletonSites {
    param(
        [Parameter(Mandatory = $true)]
        [System.Collections.Hashtable] $Msa,

        [switch] $KeepMonomorphic
    )

    $Headers = @()
    $Sequences = @()
    $Result = @{}

    # Extract sequences into convenient array
    foreach ($entry in $Msa.GetEnumerator()) {
        $Headers += $entry.Key
        $Result[$entry.Key] = ""

        if ($Sequences.Count -gt 0) {
            if ($Sequences[0].Length -ne $entry.Value.Length) {
                Write-Error "MSA sequences differ in length"
                Return
            }
        }

        $Sequences += $entry.Value
    }

    if ($Sequences.Count -eq 0) {
        Return @{}
    }

    # check all sites
    $Range = 0..($Sequences[0].Length - 1)
    $RemovedSites = 0
    foreach ($Site in $Range) {
        # check if it is a singleton
        $CharacterCounts = @{}

        # count character states
        foreach ($Sequence in $Sequences) {
            $Char = $Sequence[$Site]
            if ($CharacterCounts.ContainsKey($Char)) {
                $CharacterCounts[$Char] += 1
            } else {
                $CharacterCounts[$Char] = 1
            }

            if ($CharacterCounts.Keys.Count -gt 2) {
                break
            } else {
                if (($CharacterCounts.GetEnumerator() | Where-Object { ($_.Key -ne "-") -and ($_.Value -gt 1) } | Measure-Object).Count -gt 1) {
                    break
                }
            }
        }

        if ($CharacterCounts.Count -eq 1 -and (-not $KeepMonomorphic)) {
            # Monomorphic site encountered
            $RemovedSites += 1
            continue
        }

        if ($CharacterCounts.Count -eq 2 -and (-not $KeepMonomorphic)) {
            if ($CharacterCounts -contains "-") {
                # Monomorphic site encountered, because the rest is gaps
                $RemovedSites += 1
                continue
            }
        }

        if ($CharacterCounts.Count -eq 2) {
            if (($CharacterCounts.GetEnumerator() | Where-Object { $_.Value -gt 1 } | Measure-Object).Count -lt 2) {
                # singleton site encountered
                $RemovedSites += 1
                continue
            }
        }

        # append sites to final sequences
        foreach ($Index in 0..($Headers.Count - 1)) {
            $Result[$Headers[$Index]] += $Sequences[$Index][$Site]
        }
    }

    Write-Host "Removed $RemovedSites Sites."
    Return $Result
}

<#
 .SYNOPSIS
 Projects the alignment of a given MSA onto an unaligned Multi-FASTA file with the same taxa.

 .DESCRIPTION
 Given a Multi-Sequence-Alignment and a set of unaligned sequences with the same set of identifiers,
 project the gaps of the existing alignment onto the unaligned sequences, creating an analogous alignment.
 This only works correctly, if the unaligned sequences have the same length as the aligned sequences (without gaps).
 The unaligned sequence map may contain sequences which are not present in the alignment. Those sequences will not
 be present in the projected alignment.

 .PARAMETER Msa
 Hashtable containing the aligned sequences.

 .PARAMETER MsaPath
 Path to a fasta file containing aligned sequences.

.PARAMETER UnalignedSequences
 Hashtable containing multiple unaligned sequences with the same identifiers as the Msa sequences.

 .PARAMETER UnalignedPath
 Path to a multi-fasta file containing multiple unaligned sequences with the same identifiers as the Msa sequences.

 .OUTPUTS [System.Collections.Hashtable]
 Returns a hashtable containing the unaligned sequences with gaps inserted in analogous positions as in the given
 alignment.
#>
function ConvertTo-AlignmentProjection {
    param(
        [Parameter(Mandatory = $true, ParameterSetName = "in_map_out_map")]
        [Parameter(Mandatory = $true, ParameterSetName = "in_map_out_file")]
        [System.Collections.Hashtable] $Msa,

        [Parameter(Mandatory = $true, ParameterSetName = "in_file_out_map")]
        [Parameter(Mandatory = $true, ParameterSetName = "in_file_out_file")]
        [string] $MsaPath,

        [Parameter(Mandatory = $true, ParameterSetName = "in_map_out_map")]
        [Parameter(Mandatory = $true, ParameterSetName = "in_file_out_map")]
        [System.Collections.Hashtable] $UnalignedSequences,

        [Parameter(Mandatory = $true, ParameterSetName = "in_map_out_file")]
        [Parameter(Mandatory = $true, ParameterSetName = "in_file_out_file")]
        [string] $UnalignedPath
    )

    # read in MSA
    if ($PSCmdlet.ParameterSetName.StartsWith("in_file")) {
        $Msa = Import-MultiFasta -Path $MsaPath
    }

    if ($PSCmdlet.ParameterSetName.EndsWith("out_file")) {
        $UnalignedSequences = Import-MultiFasta -Path $UnalignedPath
    }

    $ProjectedAlignment = @{}

    foreach ($entry in $Msa.getEnumerator()) {
        $AlignedHeader = $entry.Key
        $AlignedSequence = $entry.Value

        if (-not ($UnalignedSequences.ContainsKey($AlignedHeader))) {
            Write-Error "No sequence $AlignedHeader found among unaligned sequences."
            Return $null
        }

        $TargetSequence = $UnalignedSequences[$AlignedHeader]
        $Index = 0
        $AlignedTargetSequence = ""

        foreach ($char in $AlignedSequence.ToCharArray())
        {
            if ($char -eq '-')
            {
                $AlignedTargetSequence += '-'
            }
            else
            {
                $AlignedTargetSequence += $TargetSequence[$Index]
                $Index++
            }
        }

        $ProjectedAlignment[$AlignedHeader] = $AlignedTargetSequence
    }

    return $ProjectedAlignment
}